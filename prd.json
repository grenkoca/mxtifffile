{
  "project": "mxtifffile",
  "branchName": "ralph/mxtifffile-release-and-tests",
  "description": "Rename package to mxtifffile across all metadata, fix the PyPI publish workflow, prepare a conda-forge recipe, add release automation, and build a full pytest test suite with CI.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Rename package metadata to mxtifffile",
      "description": "As a maintainer, I want all package metadata files to reflect the new name mxtifffile so that the published package matches the class and module name used in code.",
      "acceptanceCriteria": [
        "setup.cfg `name` field changed from `qptifffile` to `mxtifffile`",
        "setup.cfg `description` updated to describe mxtifffile (not QPTIFF-specific language)",
        "setup.cfg `url` and `project_urls` updated to https://github.com/grenkoca/qptifffile",
        "pyproject.toml `[tool.setuptools.package-data]` key changed from `qptifffile` to `mxtifffile` if present",
        "`python -m build` completes and the resulting .whl and .tar.gz filenames contain `mxtifffile`",
        "`pip install dist/mxtifffile-*.whl && python -c 'import mxtifffile'` succeeds",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Fix PyPI GitHub Actions workflow for mxtifffile",
      "description": "As a maintainer, I want the existing python-publish.yml workflow to correctly point to the mxtifffile PyPI project so that releases publish to the right package page.",
      "acceptanceCriteria": [
        "`environment.url` in `.github/workflows/python-publish.yml` changed from `https://pypi.org/p/qptifffile` to `https://pypi.org/p/mxtifffile`",
        "No other references to `qptifffile` remain in the workflow file",
        "A comment is added noting that the PyPI trusted publishing environment must be configured for mxtifffile on PyPI.org (one-time manual step)",
        "Workflow YAML is syntactically valid (no parse errors when loaded as YAML)",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Fix conda-forge meta.yaml recipe for mxtifffile",
      "description": "As a maintainer, I want a correct meta.yaml that can be submitted to conda-forge/staged-recipes as the first step toward conda distribution.",
      "acceptanceCriteria": [
        "`meta.yaml` top-level `name` variable changed from `qptifffile` to `mxtifffile`",
        "`meta.yaml` `version` matches the version in setup.cfg (currently 0.0.2)",
        "`source.url` uses the correct PyPI tarball URL pattern: `https://pypi.io/packages/source/m/mxtifffile/mxtifffile-{{ version }}.tar.gz`",
        "`source.sha256` placeholder replaced with comment `# Run: curl -s https://pypi.org/pypi/mxtifffile/{{ version }}/json | python -m json.tool | grep sha256`",
        "`about.home` set to `https://github.com/grenkoca/qptifffile`",
        "`about.summary` set to `A config-driven multiplex TIFF reader supporting QPTIFF, OME-TIFF, and ImageJ formats`",
        "`test.imports` changed from `qptiff` to `mxtifffile`",
        "No placeholder strings (yourusername, SHA256 hash of your package) remain in the file",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Add release automation workflow to update meta.yaml",
      "description": "As a maintainer, I want a GitHub Actions workflow that automatically updates meta.yaml with the correct version and SHA256 hash on each release so I can submit the conda-forge PR without manual hash lookup.",
      "acceptanceCriteria": [
        "New workflow file `.github/workflows/update-conda-recipe.yml` exists",
        "Workflow triggers on `release: [published]` only (not drafts)",
        "Workflow fetches the SHA256 of the mxtifffile source tarball from the PyPI JSON API (`https://pypi.org/pypi/mxtifffile/<version>/json`)",
        "Workflow updates `meta.yaml` `version` and `sha256` fields using sed or a Python script",
        "Workflow opens a PR against main with the updated meta.yaml (uses `peter-evans/create-pull-request` action or equivalent)",
        "Workflow YAML is syntactically valid",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-005",
      "title": "Document the release process in RELEASE.md",
      "description": "As a maintainer, I want a clear release checklist so that any contributor can cut a release without guessing the correct steps.",
      "acceptanceCriteria": [
        "`RELEASE.md` file exists at the repo root",
        "Covers: bump version in setup.cfg, tag a GitHub release, what PyPI workflow does automatically",
        "Covers: how the update-conda-recipe.yml workflow generates the updated meta.yaml PR",
        "Covers: how to submit the one-time PR to conda-forge/staged-recipes with a link to https://github.com/conda-forge/staged-recipes",
        "Notes that after the first staged-recipes PR is merged, the conda-forge autotick bot handles future version bumps automatically",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "Set up pytest infrastructure",
      "description": "As a developer, I want a properly configured test environment so that tests can be discovered, run, and measured for coverage with a single command.",
      "acceptanceCriteria": [
        "`tests/` directory created at the repo root with an empty `__init__.py`",
        "`tests/conftest.py` defines three path fixtures: `qptiff_path` → `test_data/Roche_Fusion_TonsilandIntestine_1.qptiff`, `ome_tiff_path` → `test_data/A-1.ome.tif`, `ome_tiff_path_2` → `test_data/Untitled.ome.tif`",
        "Each fixture uses `pytest.importorskip` or `pytest.skip` if the file does not exist on disk",
        "`pytest` and `pytest-cov` added to `[options.extras_require]` under a `dev` key in `setup.cfg`",
        "`[tool.pytest.ini_options]` added to `pyproject.toml` with `testpaths = [\"tests\"]` and `addopts = \"--cov=src/qptifffile --cov-report=term-missing\"`",
        "`pytest --collect-only` runs without errors",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "Tests for format_config module",
      "description": "As a developer, I want tests for format_config.py so I know the config loader correctly reads formats.json, returns typed dataclasses, and handles custom paths.",
      "acceptanceCriteria": [
        "`tests/test_format_config.py` exists",
        "Test: `load_formats()` returns a non-empty list",
        "Test: each item in the list is a `FormatConfig` instance with a non-empty `id` string",
        "Test: each item has a `detection` attribute that is a `FormatDetection` instance",
        "Test: `load_formats(path=<tmp_json>)` loads configs from a custom JSON file created with `tmp_path`",
        "Test: `load_formats(path='/nonexistent/path.json')` raises `FileNotFoundError`",
        "Test: calling `load_formats()` twice returns the same list object (identity check with `is`); use `load_formats.cache_clear()` in teardown",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-008",
      "title": "Tests for format_detector module",
      "description": "As a developer, I want tests for format_detector.py so that the detection logic correctly identifies QPTIFF, OME-TIFF, and ImageJ files and respects OME-TIFF priority.",
      "acceptanceCriteria": [
        "`tests/test_format_detector.py` exists",
        "Test: `detect_format(tif, configs)` returns config with `id='ome-tiff'` for the `A-1.ome.tif` fixture (open with `tifffile.TiffFile`)",
        "Test: `detect_format(tif, configs)` returns config with `id='ome-tiff'` for the `Untitled.ome.tif` fixture",
        "Test: `detect_format(tif, configs)` returns config with `id='qptiff'` for the `Roche_Fusion_TonsilandIntestine_1.qptiff` fixture",
        "Test: `detect_format(tif, configs)` returns `None` for a `MagicMock` tifffile handle with `series=[]` and all `is_*` flags False",
        "Test: OME-TIFF config returned (not ImageJ) for a mock where both `is_ome=True` and `is_imagej=True`",
        "Test: `_strip_xml_comments('<!-- comment -->text')` returns `'text'`",
        "Test: `_page0_root_tag` returns `None` for a mock with `series[0].pages = []`",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-009",
      "title": "Tests for parsers module",
      "description": "As a developer, I want tests for all three parser classes so I know each returns a correctly structured list of channel dicts for real files.",
      "acceptanceCriteria": [
        "`tests/test_parsers.py` exists",
        "Test: `PerPageParser` on the QPTIFF fixture returns a list of dicts each containing a non-empty `biomarker` string",
        "Test: `FileLevelParser` on `A-1.ome.tif` returns a list of dicts each containing a non-empty `biomarker` string",
        "Test: the length of channels returned by `FileLevelParser` on `A-1.ome.tif` is greater than zero",
        "Test: no channel dict in any parser result contains `None` for the `index` key",
        "Test: `FileLevelParser` on a mock with malformed XML (not valid XML string) raises an exception rather than returning an empty list silently",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-010",
      "title": "Tests for heuristic detection module",
      "description": "As a developer, I want tests for heuristic.py so the fallback detector finds channels by anchor marker in files that don't match any known format.",
      "acceptanceCriteria": [
        "`tests/test_heuristic.py` exists",
        "Test: `ANCHOR_MARKER` imported from `mxtifffile` equals `'DAPI'`",
        "Test: `heuristic_detect(tif)` returns a non-empty list for at least one of the real test data fixtures (QPTIFF or OME-TIFF containing 'DAPI' in metadata)",
        "Test: `heuristic_detect(tif)` with a mock tifffile containing no XML that includes the anchor marker returns `None` or raises `MxTiffFormatError`",
        "Typecheck passes"
      ],
      "priority": 10,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-011",
      "title": "Integration tests for MxTiffFile with real test data",
      "description": "As a developer, I want end-to-end integration tests using real test data so that I know MxTiffFile correctly opens files, exposes channels, and reads pixel data.",
      "acceptanceCriteria": [
        "`tests/test_mxtifffile.py` exists",
        "Test: `MxTiffFile(qptiff_path)` opens without raising any exception",
        "Test: `MxTiffFile(ome_tiff_path)` opens without raising any exception",
        "Test: `MxTiffFile(ome_tiff_path_2)` opens without raising any exception",
        "Test: after opening any real file, `tif.channels` (or the equivalent attribute) is a list with length > 0",
        "Test: each element in `tif.channels` has a `'name'` or `'biomarker'` key with a non-empty string value",
        "Test: `MxTiffFile(qptiff_path, formats_config=str(tmp_path / 'custom.json'))` raises `FileNotFoundError` when the custom json does not exist",
        "Typecheck passes"
      ],
      "priority": 11,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-012",
      "title": "Error handling and edge case tests",
      "description": "As a developer, I want tests for failure modes so that mxtifffile fails loudly and clearly rather than silently returning bad data.",
      "acceptanceCriteria": [
        "Test: `MxTiffFile('nonexistent_file.tif')` raises `FileNotFoundError` or `tifffile.TiffFileError`",
        "Test: opening a file that is a plain text file renamed to .tif raises an exception (use `tmp_path` to create a fake .tif with text content)",
        "Test: `MxTiffFormatError` can be imported with `from mxtifffile import MxTiffFormatError`",
        "Test: `MxTiffFormatError` is a subclass of `Exception`",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-013",
      "title": "Backward compatibility tests for QPTiffFile alias",
      "description": "As a developer, I want tests confirming that the deprecated QPTiffFile alias still works so that existing user code is not silently broken.",
      "acceptanceCriteria": [
        "Test: `from mxtifffile import QPTiffFile` succeeds without error",
        "Test: `QPTiffFile(qptiff_path)` opens without error (using `pytest.warns(DeprecationWarning)` context manager)",
        "Test: the `DeprecationWarning` message contains the word 'deprecated' or 'QPTiffFile'",
        "Test: `isinstance(QPTiffFile(qptiff_path), MxTiffFile)` is `True` (also within `pytest.warns` context)",
        "Typecheck passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-014",
      "title": "GitHub Actions CI workflow for tests on PRs",
      "description": "As a maintainer, I want tests to run automatically on every PR to main so that regressions are caught before merge.",
      "acceptanceCriteria": [
        "New workflow file `.github/workflows/tests.yml` exists",
        "Workflow triggers on `pull_request` with `branches: [main]`",
        "Workflow uses a matrix with `python-version: ['3.10', '3.12']` on `ubuntu-latest`",
        "Workflow steps: `actions/checkout@v4` → `actions/setup-python@v5` → `pip install -e '.[dev]'` → `pytest`",
        "Workflow fails with non-zero exit code if any test fails",
        "Workflow uploads the coverage report (`coverage.xml` or `.coverage`) as an artifact using `actions/upload-artifact@v4`",
        "Workflow YAML is syntactically valid",
        "Typecheck passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": ""
    }
  ]
}
